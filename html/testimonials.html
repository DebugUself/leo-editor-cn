
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>人们对 Leo 的评价 &#8212; Leo 5.6 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="致谢" href="acknowledgements.html" />
    <link rel="prev" title="Leo 简介" href="preface.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="acknowledgements.html" title="致谢"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="preface.html" title="Leo 简介"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="leo_toc.html">Leo 5.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="preliminaries.html" accesskey="U">前言</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="leo">
<h1>人们对 Leo 的评价<a class="headerlink" href="#leo" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="id1">
<p class="topic-title first">内容</p>
<ul class="simple">
<li><a class="reference internal" href="#id2" id="id12">Leo 是革命性的</a></li>
<li><a class="reference internal" href="#leo-python" id="id13">Leo 是一个典型的 Python 应用程序</a></li>
<li><a class="reference internal" href="#id3" id="id14">Leo 很有趣, 甚至上瘾</a></li>
<li><a class="reference internal" href="#leo-ide" id="id15">Leo 是一个灵活, 功能强大的IDE</a></li>
<li><a class="reference internal" href="#id4" id="id16">Leo 是一个极好的提纲</a></li>
<li><a class="reference internal" href="#leo-pim" id="id17">Leo 是一个优秀的 PIM</a></li>
<li><a class="reference internal" href="#id5" id="id18">Leo 是一个极好的文档管理工具</a></li>
<li><a class="reference internal" href="#id6" id="id19">Leo 简化了对复杂系统的理解</a></li>
<li><a class="reference internal" href="#id7" id="id20">Leo 是稳定的, 精心设计的, 支持良好的</a></li>
<li><a class="reference internal" href="#steve-zatz-clean" id="id21">Steve Zatz 解释了为什么 &#64;clean 改变了一切</a></li>
<li><a class="reference internal" href="#id8" id="id22">来自 Leo 的开发者引用</a></li>
<li><a class="reference internal" href="#id9" id="id23">更长的引用…</a><ul>
<li><a class="reference internal" href="#speed-reams-slashdot-article" id="id24">Speed Ream’s slashdot article</a></li>
<li><a class="reference internal" href="#joe-orr" id="id25">Joe Orr</a></li>
<li><a class="reference internal" href="#dan-winkler" id="id26">Dan Winkler</a></li>
<li><a class="reference internal" href="#dan-winkler-2" id="id27">Dan Winkler 2</a></li>
<li><a class="reference internal" href="#dan-winkler-3" id="id28">Dan Winkler 3</a></li>
<li><a class="reference internal" href="#steve-litt" id="id29">Steve Litt</a></li>
<li><a class="reference internal" href="#dave-williams" id="id30">Dave Williams</a></li>
<li><a class="reference internal" href="#john-lunzer" id="id31">John Lunzer</a></li>
<li><a class="reference internal" href="#john-lunzer-2" id="id32">John Lunzer 2</a></li>
<li><a class="reference internal" href="#adrian-calvin" id="id33">Adrian Calvin</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10" id="id34">为什么 Leo 值得注意</a><ul>
<li><a class="reference internal" href="#offray-luna-cardenas" id="id35">Offray Luna Cárdenas</a></li>
<li><a class="reference internal" href="#speed-s-comments" id="id36">Speed’s comments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11" id="id37">我是如何发现 Leo 的</a><ul>
<li><a class="reference internal" href="#satish-goda" id="id38">Satish Goda</a></li>
<li><a class="reference internal" href="#rob-keeney" id="id39">Rob Keeney</a></li>
<li><a class="reference internal" href="#chris-george" id="id40">Chris George</a></li>
<li><a class="reference internal" href="#terry-brown" id="id41">Terry Brown</a></li>
<li><a class="reference internal" href="#kent-tenney" id="id42">Kent Tenney</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id12">Leo 是革命性的</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>“几星期以来, 我一直在使用 Leo, 我对它充满了热情. 我认为它是自电子表格发明以来最令人惊讶的软件. “—Anon.</p>
<p>“我们使用 Leo 的人知道这是一个突破性工具, 是编写代码的全新方式. “—Joe Orr</p>
<p>“我是 Leo 的忠实粉丝. 我认为它很可能是我曾经使用过的最具革命性的编程工具, 它(连同 Python 语言)彻底改变了我对未来编程(甚至是写作)的看法. “—Shakeeb Alireza</p>
<p>“非常感谢 Leo. 我认为我的数据处理方式将永远改变…我确信 [Leo] 将是一场革命. 这场革命不亚于将书的顺序线性组织变为网页式的超链接页面. 让我印象深刻主要概念是源代码列表不再是主要的焦点. 你聚焦于源代码的非线性, 分层, 可折叠的提纲.”—Korakot Chaovavanich</p>
<p>“就我能够管理的项目数量以及我能够以有用的方式发现并组织和存储信息多少而言, Leo对我来讲是一个巨大的飞跃.”—Dan Winkler</p>
<p>“哇, 哇, 哇…我终于明白了如何使用克隆, 我意识到这正是我想要组织我的信息的方式. 我的数据有多个视图, 就像我的想法一样, 完全可以相互链接.”—Anon</p>
<p>“Edward…你提出了可能是自 VI 和 Emacs 以来, 在代码操作中最强大的新概念.”—David McNab</p>
<p>“Leo 是…朝着正确的编程方向迈出的革命性的一步.”—Brian Takita</p>
</div>
<div class="section" id="leo-python">
<h2><a class="toc-backref" href="#id13">Leo 是一个典型的 Python 应用程序</a><a class="headerlink" href="#leo-python" title="Permalink to this headline">¶</a></h2>
<p>“感谢这样一个精彩的程序-每个人都应该使用它! 它使 Java 思维导图软件脱颖而出, 赢得了 Sourceforge 本月的项目!” —Derick van Niekerk.</p>
<p>“几年前, 我会说 Zope 是排名第一的 Python 展示 (showcase), 但是现在我 100% 同意 Leo 处于顶峰.” —Jason Cunliffe</p>
<p>“Leo 是我所知道的最有趣的 Python 项目…我看到许多食材发布在 Daily Python 页面上, 但我通常会打哈欠, 然后来这个论坛看看正在烹饪什么.” —Anon</p>
<p>“多么新颖的不同想法的原创综合, 为什么其他开源项目不能改变我的想法?” —Anon</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id14">Leo 很有趣, 甚至上瘾</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>“当我第一次打开 Leo, 那是出于好奇. 但是用过之后…我再也不会回去了. 它们将不得不把 Leo 从我冰冷, 麻木的手指里撬开! 说真的, 他应该改名为 <cite>强效可卡因</cite>, 因为它让人上瘾. 我准备开始一个 12 步小组. ” —Travers A. Hough</p>
<p>“我感觉又对编程上瘾了…事实上 [Leo] 已经复活了我的一个死亡项目 :) 提纲已经被证明在测试想法方面最为自由.” —Anon</p>
<p>“在过去的几天里, 我完全被 Leo 诱惑了. 我告诉你, 我不能把它放下. 我觉得自己像个有着闪亮新自信车的孩子…我已经开始用我想要的新方式在未来使用这个工具.” —Lyn Adams Headley</p>
<p>感谢这个伟大的杰作–我爱 Leo!!! —Josef Dalcolmo</p>
<p>Leo 已经简化了更新和创建新的脚本, 并且 .bats 在同一地方保存了相似的信息. 这几乎是一个成瘾戒断效应, 我可以使用 Leo &amp; Python 在比过去更短的时间内完成操作. —Anon</p>
<p>Leo 是我喜爱的思维胶囊 ;-)</p>
<ul class="simple">
<li>她可以容纳我的各种作品 (小说, 代码, 幻灯片, 文档…)</li>
<li>并且她可以神奇的在相同的时间和地点记录我混乱的思维, 而不会干扰我的工作…</li>
<li>luvin Leo, 让我混沌的头脑自由和构建工作的出口!</li>
<li>我所有的幻灯片都是用 rst2s5 制作</li>
<li>在 Leo 中编写 rst</li>
<li>使用 CLI 工具生成 html 幻灯片</li>
<li>简单, 极客, 自由! — 周琦 (Zoom.Quiet)</li>
</ul>
</div>
<div class="section" id="leo-ide">
<h2><a class="toc-backref" href="#id15">Leo 是一个灵活, 功能强大的IDE</a><a class="headerlink" href="#leo-ide" title="Permalink to this headline">¶</a></h2>
<p>“[Leo] 应该替换或大大增强我使用的开发工具. ” —Zak Greant</p>
<p>“Leo 是提纲和编程的联姻. 纯粹的天才. 我对这个工具留下深刻印象的主要原因是它不影响您对工具的选择. 你可以使用任何语言的 IDE, 并在 Leo 和它之间来回切换. ” —Austin King</p>
<p>“Leo 是我有幸使用的最好的 IDE. 现在我已经用了 2-3 个月. 它不仅完全改变了我的编程方式, 而且改变了我存储和组织工作所需要的所有信息的方式. ” —Ian Mulvany</p>
<p>“我只有一周的 Leo 经验, 但是我已经知道它将是我的默认 IDE/项目管理器…人们抱怨缺乏像 Idle 这样的免费/标准的 Python IDE 项目管理器. Leo 很明显地解决了这个问题, 并以商业工具无法触及的方式. ” —Marshall Parsons</p>
<p>“我已经使用 Leo 大约 3 周了, 我几乎不再使用其他编程编辑器了…我觉得使用起来很简单, 很愉快. 我计划将它作为我的代码评论演示工具.” —Jim Vickroy</p>
<p>“我完全被这样简单的想法的力量震惊了! 它非常好用, 并且我可以立刻看到使用 Leo 代替 flat file 编辑器的好处. ” —Tom Lee</p>
<p>“我认为你真正地展示了开源可以做什么, 并且您当前的轨迹可以让你将 Emacs 踢进计算机历史垃圾堆.” —Dan Winkler</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id16">Leo 是一个极好的提纲</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>“Word 提纲非常有用. 但是 Leo 让 Word 看起来像一个笨重的玩具. ” —Joe Orr</p>
<p>“Leo 是一款交互式编辑器, 可以将文本片段按层次和顺序组织到一个或多个文件和分层文件夹中, 而不会限制文本片段的数量和大小以及层次结构的深度…” —Alex Abacus</p>
<p>“Leo 让我想起许多我喜欢过的东西, 我曾用过 Userland 的 Frontier (一个带有本地数据库 (cms) 的提纲内容管理系统), - 但是 Frontier 对我来说不够灵活, 并且它不是面向编码的…, 并且您无法来回渲染页面 (Leo 大胜). 这真是个极好的工具-在短短的几天内, 我已经开始在我的所有项目中使用它了, 我还没弄明白没有它之前我是如何生活的” —John Sequeira</p>
<p>“Leo 正是我想要寻找的那种提纲-好样的!” —Steve Allen</p>
<p>“Leo 创建活文档. 想法可以逐步组织和重组, 然后插入到项目的适当位置. 提纲变成流动的, 允许无限的深度, 并使用节点的克隆, 任意级别的复杂度…[其它的] 提纲在文档上施加结构…Leo 是不同的. 不同于施加结构, 它允许你施加你自己基础架构, 然后随心所欲的发挥你的创造力. 这就带来了在制作文档时必要的创造力的混乱. 当涉及到章节中的场景排列, 节点结构创造了最大地灵活性. 再见, 复制和粘贴, 你好, 拖放. ” —Chris George, 于 <a class="reference external" href="https://refiction.com/resource-reviews/leo-editor-for-writers">Thrive</a></p>
</div>
<div class="section" id="leo-pim">
<h2><a class="toc-backref" href="#id17">Leo 是一个优秀的 PIM</a><a class="headerlink" href="#leo-pim" title="Permalink to this headline">¶</a></h2>
<p>“如果你像我一样, 你有一种随着时间的推移收集到的基础知识库. 而且你有项目, 在那里使用这些信息. 现在, 用传统的提纲, 你开始将这些信息加倍, 因为你希望为项目提供项目所需的信息. 你也可以用 Leo 做这个, 但是如果你在一个地方更改文本, 它也会在其它地方更新! 这是我在其它提纲从没有看到的功能 (我尝试过一些). 太神了! Leo 直接支持我工作的方式!” —F. Geiger</p>
<p>“又一天, 使用 Leo 的另一个突破-现在我意识到 Leo 是最佳地 URL 书籍管理器. 在我的浏览器中没有书签菜单或收藏列表. 通过 &#64;url 指令, 我可以只需要双击 URL 即可在我的浏览器中来打开它. Leo 让我在一个层次结构 (或多个层次结构) 安排URL, 附加注释, 保存我在网站阅读的东西的剪报. 它远胜于浏览器内置的任何东西, 它让我在不同的平台和不同的机器上轻松使用不同的浏览器 (尝试用浏览器的内置书签管理器).” —Dan Winkler</p>
<p>“我是一个业余的摄像师. 我使用普通的 35 mm 胶片拍摄我的照片. 整个周末, 我使用 Leo 来组织我的照片清单. 这相当有帮助-我可以为我放大的图片和提交到当地的相机俱乐部的图片分别设置节点. 谢谢!”—Rich Reis</p>
<p>“克隆是纯粹的天才!…Leo 的克隆工具, 让我可以在 CFA 课程资料上创建数个视图. 我的主要视图遵循规定的学习指南. 另一个视图像教科书一样组织. 还有一个给我一个术语表. 而且当我完成后, 我会有一些不错的库…我可以之后在其他项目中复用.” —Michael Manti</p>
<p>尽管我不是程序员, 但我用 Leo 作为我的 “智能 PIM ”已经有好几年了-我用 Leo 组织我的 (复杂) 生活. 非常感谢 Edward 等人的伟大应用程序 – vili &lt;<a class="reference external" href="mailto:viljem&#46;tisnikar&#37;&#52;&#48;gmail&#46;com">viljem<span>&#46;</span>tisnikar<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>我曾长时间将 Leo 用作 PIM 来追踪我的工作, 但由于其明确的议程和工作追踪的能力而转移到 emacs org 模式一段时间. 但是我回到了Leo, 因为在查看项目的各个方面时它看上去更加灵活. 对于最近一些性能数据收集工作, 在一个提纲下是项目背后的原则, 项目代码 (生成), 项目网页 (从一个 &#64;rst 节点树生成)和项目部署 (只需要点击按钮). 人们可以快速地将焦点从一个方面转移到另一个面, 并在需要时使用克隆来真正地深入到一个区域 (对我来说通常的是代码). Leo 是一个令人印象深刻的工具, 我只抓住了表面–Robert Shanley.</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id18">Leo 是一个极好的文档管理工具</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>“我已经在 WordPerfert, Ventura, Word, PageMaker 和 FrameMaker 中编写了文档, 即使它们创建了极好的外观和有用的文档, 但它们从来都无法做到我一直在寻找的东西. HTML, 编译的帮助文件和更高版本的 PDF 越来越近, 但仍然没有达到我在寻找的…我认为我在 Leo 中找到了它, 这是一种制作 “活” 文档的方式. 一个由离散部分构建的文档, 可以随时重新组织, 以满足不同观众的需求…我已经开始将 IT 程序手册从 Open Office 转换为 Leo, 因为我知道它对我和其他人将是非常有用的. 仅仅是在 IT 手册中保留系统维护脚本的可能性就是令人难以置信的.” —David Nichols</p>
<p>“在 rst2 插件的帮助下, [Leo 是] 我在撰写学术论文的早期阶段遇到的最好的提纲.”</p>
<p>“Leo 是一个理想的文档工具, 收集各种 readme.txt 文件, 源文件的评论…以及配置文件本身.” —Kent Tenney</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id19">Leo 简化了对复杂系统的理解</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>“就像结构化程序设计揭示和规范程序的流程控制一样, [Leo] 允许设计者同时在多个层次上揭示和规范结构: 数据结构, 对象结构, 实体关系结构, 客户端-服务器结构, 设计模式结构, 时间结构, 项目管理结构, 以及任何与系统相关的其他结构.” —Steven P. Schaefer</p>
<p>“使用 Leo 的一个有趣观察是, 当我 ‘Leo-ise’ 其他人的代码时, Leo 使代码的结构如此透明, 设计缺陷变得非常明显. 例如, 由于缺乏因式分解引起的维护痛苦.”—David McNab</p>
<p>“Leo 是一个强大的工具, 可以将文本组织到树结构中的, 从树的角度来讲, 它通常会攻击很多问题.” —Joe Orr</p>
<p>“我发现这篇博客的入口是由某人 (实际上是一位才华横溢的同事) 抱怨她不得不维护的一些糟糕的代码: <a class="reference external" href="http://snippy.ceejbot.com/wiki/show/start/2003/01/29/001">http://snippy.ceejbot.com/wiki/show/start/2003/01/29/001</a> 她说:’你需要一台推土机开始重构它’. 这就是我的提示, 来写很长一段留言, 解释确实有这样推土机, 它被称作 Leo. (你可以在那里看到我的留言, 回复她原来的帖子). 我给了她我的诀窍, 如何将将别人混乱, 可怕的代码放入 Leo , 以及如何将其分解成可管理的块.” —Dan Winkler</p>
<p>“Ed, 你继续挑战极限. 令人惊奇的是, 它占用的空间不会像其他设计师手中那样每几个月就翻一番. 通过删除约束来增加功能, 在添加单元测试时进行热重构. 忘了这本书, 我会付钱看电影.”</p>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id20">Leo 是稳定的, 精心设计的, 支持良好的</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>“我对 Leo 表现出的稳定性和实用性印象深刻.”—Marcus A. Martin</p>
<p>“Leo 非常稳定. 开源软件的文档通常很弱. Leo 不是这样的: Leo 的记录非常好.”—F. Geiger</p>
<p>“Leo 是无法想象的有用. 而且我经常从已经知道 (!) 如何去做的东西上发现新事物. 事实上, 我被 Edward 投入在 Leo 及其用户社区的永无止境的资源和耐心所惊讶. 太棒了!” —Gil Shwartz</p>
<dl class="docutils">
<dt>我强烈感受到, Ed Ream, 我们永远有耐心的, 高产的 Leo 架构师值得提名 [ActiveState 开源奖]. 其他原因包括:</dt>
<dd><ul class="first last simple">
<li>提供第一个可用的可视化文字编程工具.</li>
<li>添加大量的新功能.</li>
<li>在代码编辑器中, 实现以前难以想象的杠杆量.</li>
<li>消除了大量琐碎的编程劳动.</li>
<li>不懈地和耐心地支持用户, 并满足各种各样的功能需求.</li>
</ul>
</dd>
</dl>
<p>—David McNab</p>
</div>
<div class="section" id="steve-zatz-clean">
<h2><a class="toc-backref" href="#id21">Steve Zatz 解释了为什么 &#64;clean 改变了一切</a><a class="headerlink" href="#steve-zatz-clean" title="Permalink to this headline">¶</a></h2>
<p>我只是想提供我自己关于 &#64;clean 重要性的看法. 我看过这个小组相当多的帖子, 因为我觉得讨论很有趣, 但是我已经放弃了 Leo 作为日常工具, 主要是因为 &#64;file 节点中的 sentinel. 即使是单独的项目, 我也发现他们在视觉上没有吸引力, 而且当我使用外部编辑器编辑文件时偶尔会感到困惑. 我有时在 Leo 中会开启一个项目, 特别是如果它是基于我过去使用 Leo 开发的代码, 然后使用旧的 &#64;nosent 来保存没有结构注释的代码版本, 然后使用我外部选择的编辑器而根本不使用 Leo. 我丢失了许多 Leo 特性但就是无法客服结构注释问题.</p>
<p>&#64;clean 似乎真的解决了我的所有问题. 尤其是-并且不知怎地这点对我来讲并未充分的强调-它似乎完全支持组织节点. 它们是 Leo 最伟大的事情之一-它很乐意初步构想你的程序结构, 但完全取决于你来决定这个结构和做事情的能力, 比如分解长方法, 方法组, GUI 代码中的菜单操作组, 等等, 都是 Leo 非常酷的事情之一. 我对 &#64;clean 处理外部变化的有限但不断增长的经验, 主要是与增量代码的更改有关, 并且新行的分配是合理的, 如果你不喜欢外部更改的处理方式, 你可以随时快速地修改它们.</p>
<p>已经有一些关于恢复节点的帖子, 对比有外部变化的新旧节点. 我认为这是天才之举. 相对于希望 Leo 能够正确引入外部变化, 如果你想要仔细观察的话, 它就在那里了. 没有这点, 我对外部的改变被正确的应用不会有信心, 当然你可以经常做一个 git diff, 但我并不希望每次在外部更改文件都这样做, 尤其是不在将要做一个 commit 的位置.</p>
<p>有一些关于 &#64;auto v. &#64;clean 的讨论. 偏好显然是一种品味的问题. 我想说的是, 对我来说, 节点标题不受外部文件行为的影响是一个特性, 而不是问题, 因为我在标题中标注了我想要在外部编辑文件时保存的内容. 是的, 如果节点标题是方法名, 那么如果外部编辑更改方法名称, 它们将不会更新, 但这对 &#64;file 也是如此.</p>
<p>在项目上与不用 Leo 的人一起工作的能力是显而易见的; 一个也许没有结构注释的稍微不明显的好处是, 我怀疑当存储库的代码充斥着 Leo 结构注释, 则人们克隆一个 git 仓库的可能性将会降低(除非潜在的克隆者是 Leo 的忠诚者). 没有结构注释的一个缺点是-没有证据表明 Leo 正在被使用, 但是我认为这引发了更广泛的 Leo 营销问题, 我相信, 如果能够在外部文件中没有结构注释的情况下利用 Leo , 将会得到极大的帮助. — Steve Zatz</p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id22">来自 Leo 的开发者引用</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>“如果没有 Leo, 我永远不再愿意编程. “—Edward K. Ream</p>
<p>来自 Terry Brown:</p>
<blockquote>
<div><p>如果你正在寻找一个包含良好编辑器和提纲以及在 Python 中完全脚本化/交互式/”实时代码” 的 <em>环境</em>, 那么 Leo 会胜出. 当然, 就我所知, 它在这个领域是独一无二的, 但我确信即使不是这样, 它也会做得很好 :-). 除去 Python 部分, 也许有其他的一些在那, 但是谁会想要除去 Python 部分 :) 我猜测 Emacs 就像这样的环境, 只是在 Lisp 中使用了一个史前的GUI系统.</p>
<p>有时候我会想为什么 Leo 似乎吸引了对 Python 不太熟悉的人, 我想现在是因为他们不断地认识到 <em>环境</em> 的价值, 而且在这个领域没有太多的东西.</p>
<p>我的感觉是, 一般来讲, 而不是特别关于 Leo, 虽然不是每个人都需要成为一名 “程序员” , 但是每个使用计算机的人都会从中受益, 因为他们甚至能够用相当简单的 “脚本” 就能更加灵活和高效的交互, 并且减少了被其他计算环境的供应者推送的视图 “购买我们最新的产品并且通过点击你就能够做任何你想做的事儿” 的限制.</p>
</div></blockquote>
<p>来自 Jacob Peck:</p>
<blockquote>
<div><p>自从一月份发现 Leo 以来, Leo 对我的生活的影响一直很大.</p>
<p>Leo 允许我在很大程度上使我的生活自动化. 它是我的待办事项清单, 我的私人助手, 我的通讯录, 我的密码日志, 我的食谱档案, 我的 RSS 提要阅读器(由 rss.py 提供)以及我喜爱的编辑器. 它部分地为我的博客 (伴随 git, ruby 和 heroku) 提供了一些功能, 允许我通过一次点击和一点点儿的编辑来创建一个新的博客条目. 视图渲染(使用 markdown 支持!)已经改变了我编写 README 和博客帖子的方式. 除此之外, 它允许我组织几个不同的桌面游戏设计项目, 以及我的众多写作项目. 更不用说它对我理解和解码大型 python 项目的能力的影响了!</p>
<p>但是, 真正让我着迷的是的,可扩展的 Leo 是多么的疯狂. 尤其是脚本按钮是我日常工作流程不可或缺的一部分, 可以让我在过去的一个月里转变我的生产力…我现在是一个事情拿起就能完成的人 (thing-getter-doner), 并且我发现其中很大一部分是由于 Leo 强大的核心, 加上 scripting.py 和 todo.py.</p>
</div></blockquote>
<p>来自Ville M. Vainio:</p>
<blockquote>
<div><p>提纲格式帮助我逐渐地组织/再组织我的想法, 而不是从一开始将所有东西放在正确的位置, 我用很少的标题写了很多正文, 而 Leo 的方法为正文文本留下了很多空间, 因此适合我的工作流程. 我发现我最终重新浏览在 Leo 上组成的笔记, 要比浏览随便地放置在像 Evernote 的笔记或文件系统的随机文件频繁.</p>
<p>使用Leo, 我可以插入 “笔记” (大部分的内容), 生成的文件, 甚至是随机数据和操作这些数据的 python 脚本. 我用各种工具来操作这些数据, 但是 Leo 帮助我将它们组合在 “项目特定” Leo文件中.</p>
<p>我知道如何为提纲编写脚本, 因此我可以根据自己的需求轻松调出不同的工具, 直接处理标题结构.</p>
</div></blockquote>
<p>来自Terry Brown:</p>
<blockquote>
<div><p>为什么是Leo? 因为我有两个最初相同但现在不同的节点, 而且我想要查看它们之间的差异.</p>
<p>我的提纲加载了一个名为 ~/.leo/t/gen 的 &#64;file 节点, 其中包含了一个 &#64;buttons 节点和多个用于常用任务的 &#64;rclick 子节点. 我添加了一个新的 &#64;rclick diff 节点:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">selected</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">getSelectedPositions</span><span class="p">()</span>
<span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/a_diff&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
<span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/b_diff&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">selected</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;xxdiff /tmp/a_diff /tmp/b_diff &amp;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>由于还多原因, 这很可怕, 但也只花了很短的时间写出来. 现在, 这个 Leo 会话不仅具有可视化节点差异功能, 而且每个未来的会话都有加载 ~/.leo/t/gen.</p>
<p>当你想要在短时间内拥有一个功能, 而不是写一封邮件的时候 - 那么, 这就是 “为什么是 Leo”.</p>
</div></blockquote>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id23">更长的引用…</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="section" id="speed-reams-slashdot-article">
<h3><a class="toc-backref" href="#id24">Speed Ream’s slashdot article</a><a class="headerlink" href="#speed-reams-slashdot-article" title="Permalink to this headline">¶</a></h3>
<p>2002年8月28日, 在 <a class="reference external" href="http://slashdot.org/comments.pl?sid=38848&amp;amp;cid=4171478">slashdot</a>.</p>
<p>您好, 我的全名是 David Speed Ream. 我以 Speed to friends and enemies alike 而闻名, 但是我很乐意回答 David 或其他任何事情. 我是 Leo 的忠实粉丝, 实际上它是由我的兄弟 Edward编写的, 只是对我已经着色的眼镜稍微着了色. 我已经在软件产品中测试和使用 Leo 超过4年了. 我的公司目前有 50,000 多行代码在 100 多个源文件中使用了 Leo.</p>
<p>我的评论来自两个观点, 第一个是作为一个复杂的, 多模块的软件产品的项目管理器, 第二个是作为一个产品线的代码器. 对我来说, Leo 的最大的缺陷是学习曲线. 如果需要的只是使用 Leo 写代码, 那么这个学习曲线可能很浅. 然而, 在我们公司, 我们在正常编码负荷的基础上分配了 40 到 80 个小时, 以便有人加快 Leo 的速度. ROI (投资回报) 由我计算为 3 个月左右. 所以如果我聘请了一位不到 3 个月的顾问, 即使我们公司所有的源代码都必须放在 Leo 文件中, 我也不会教他 Leo, 因为我现在不会这样做.</p>
<p>我考虑到我的程序员在日常操作中比我的竞争对手的效率高出 15% 到 30%. 我的这个无法辩驳的主张是基于我的生产力的变化, 因为 Leo 从测试文档生产工具发展为我们所有的汇编, c 和 cpp 源代码的主要生产方式.</p>
<p>就个人而言, 我讨厌在编写代码时处理文档, 除了:</p>
<ol class="arabic simple">
<li>当我第一次坐下了解决新问题时. 于是文档变得相当冗长和讽刺, 就好像我是地球上唯一能解决问题的人 - 或.</li>
<li>当我回头编写自己或别人已经写好代码时, 发现文档不足以理解没有研究的代码(似乎是大多数时候).</li>
</ol>
<p>所以并不要求我的工程师或我自己去做庞大的文档工作, 也不需要我使用 Leo 来达到这个目的. 更确切的说, 是 Leo 的提纲和组织能力, 以及 Leo 从提纲中创建源文件的能力, 我认为这是一个巨大的竞争优势. 我公司的每一款产品运行都运行在 windows 从 Win 3.1 到 X 的所有版本上. 在我们的旗舰软件中, 有 10 个主要模块, 每个模块由单个 Leo 文件维护. 在 CODEC 模块中, 一个名为 compress.leo 的文件组织并创建了 7 个 .asm 文件, 44 个 .c 文件, 20个 .h 文件, 2 个 .def 文件, 4 个 .mak 文件, 等等. 这个文件可以从源代码控制中检查出, 并交给工程师来添加新的功能.</p>
<p>其中包含了 CODEC 已知的问题, 每个问题都安排在自己的克隆章节. 一个克隆章节将每个例程, 变量或类型定义组合在一起, 这些定义必须在不同的 Windows 版本间更改. 这些章节可能来自六个不同的 c 源文件, 两个汇编文件和八个 .h 文件, 另一个克隆章节将与存储有关的问题组合在一起, 这些章节根据存储配置和 TSR 配置(或缺少) 而改变. 如果在可怕的‘中断时刻’期间意外的运行了该例程, 那么另一个克隆部分将会失败(或不会失败). 另一个克隆章节是一个包含克隆的章节, 每个章节都是在工程师将 bug 分组为一堆例程, 定义等一起修复 bug 时, 在主要的 bug 被解决后命名.</p>
<p>上面没有哪个克隆章节被‘克隆’到文档中. 仅恰恰相反, 当解码器第一次写入时, 每个 c 例程或汇编模块只有一个单独文件有一些章节. 随着产品不断增加并在不同平台进行测试, 每次修复故障时, 模块的每个故障都会组织成克隆. 这就是我所说的 “自我记录代码”. 这与我坐下了记录某些东西没有任何关系. 它只是一个 bug 修复 (或产品增强) 的结构在编码完成后很长时间内存在, 只要没有人愚蠢到删除 “文档” 所发生的克隆章节</p>
<p>在实际的实践中, 这个组织的 “历史” 是如此强大, 以至于我无法开始描述它. 当工程师获得一个 Leo 文件, 而该文件已经有了由最后一个不得不在上面工作的不幸的灵魂组合在一起的 “中断时间敏感” 例程时, “反向学习曲线发生了”. 可能没有更多书写的文档, 但包含在结构中的知识可能会令人惊叹. 这当然是节省时间. 我发现这在我的情况下尤其如此. 通常我会看一些看起来完全不熟悉的代码, 并想 “这是哪个白痴写的这些废话”. 然后我会看看版本控制的评论, 并意识到我写了这些废话. 当然, 我肯定知道文档是不存在的, 但是我用来开发的克隆仍然存在, 它们总是以一种难以描述的方式来更新我的记忆.</p>
<p>这篇评论足够多了, 我只看了一下钟. 对任何愿意尝试 Leo 一周的人致以最良好的祝愿. 我希望你会为你做的感到高兴.</p>
</div>
<div class="section" id="joe-orr">
<h3><a class="toc-backref" href="#id25">Joe Orr</a><a class="headerlink" href="#joe-orr" title="Permalink to this headline">¶</a></h3>
<p>Word 提纲非常有用. 但是 Leo 让 Word 看起来像一个笨重的玩具.</p>
<p># 理由可能是克隆节点. 一个节点可以指向另一个节点. 另一种说法是一片叶子可以放在多颗树上. 例如, 假设你有一份食谱清单. 你同时将单个食谱放在多个类别甚至多个层级下. 你可以同时将 “3 bean enchilada” 放在 Recipes-Mexican 和 Food-Gas 下. 另一个例子是, 如果你是一个试图决定在哪个类下面放置一个新物种的生物学家, 你可以同时将这个物种放在这两个类下面. 实际上, 你可以构建一个三维树.</p>
<p>#2 理由可能是 Leo 提纲可以嵌入到外部文本文件中. 所以,Leo 提纲不仅仅是一个提纲, 它也是一个元结构, 可以在不改变文本的情况下添加到其他文本中, 更确切的说, 是为外部文件提供一个路径图. Microsoft Word 有一个带有注释约定的文本 (xml) 版本, 所以 Leo 甚至可以用于为 Word 文档添加提纲, 尽管它现在还没有设置. 例如, 详见 <a class="reference external" href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm">http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm</a> . 在这种情况下, Leo 的上部窗口是元结构, 底部窗口是元结构被应用的文件, 一次查看一个节点.</p>
<p>我可能没有让 #2 非常清楚, 在看到所有的可能性之前, 需要慢慢习惯. 一种可以考虑的方式是 Leo 允许你将外部文档丢放入你能的提纲中, 但外部文档仍然是独立的, 并且仍然可以单独编辑.</p>
<p>关于 Leo 的其他一些很酷的事情, 而 Word 不具备的是:
1. 纯 xml 输出很容易转换成其他格式 (Word 的下一个版本将具有真正的 XML 格式, 但不容易操作). 这样做的后果是 Leo 文件可以很容易的转换成具有完成提纲功能的网页.
2. 易于添加功能, 因为它是用 Python 和开源编程的. 也许你的普通用户无法开始修改它, 但可以加入一个令人惊讶的数量…
3. 免费, 开源, 多平台
4. Leo 用 Python 编写脚本. 例如, 应该可能使用 Python 脚本将一个 Tickler 构建到 Leo 中.</p>
</div>
<div class="section" id="dan-winkler">
<h3><a class="toc-backref" href="#id26">Dan Winkler</a><a class="headerlink" href="#dan-winkler" title="Permalink to this headline">¶</a></h3>
<p>首先, 感谢你与 Leo 取得的卓越的进步. 今天, 在大约使用3个月的旧版本后我升级了, 我很高兴的看到所有的改进都发生的如此之快. 我尤其喜爱移动到下一个克隆节点的能力. 我认为你真正地展示了开源可以做什么, 并且您当前的轨迹可以让你将 Emacs 踢进计算机历史垃圾堆.</p>
<p>所以, 今天从我的旧提纲器 (ThoughtManager, 它用 Palm 同步, 并在 Palm 上运行) 中复制出了我所有的数据 (私人的信息管理和项目管理的材料), 并放入 Leo. 它了我几小时去做. 并用我非常想要的方式来重新排列它. 但是, 有能力制作克隆并有不同的方法来查看我的数据, 如你所知, 是难以置信的. 就我而言, 对于个人信息和项目管理的事情, 我使用灵活的克隆让我能够以不同的角度查看我的数据: 1) 按照项目视角, 根据主题的逻辑层次分解, 2)按照个人视角, 无论什么时候, 在我与某人交流时, 我可以轻松的看到所有与之关联的悬而未决的项目, 这些项目可能分散在多个项目中, 3)按照优先级视角, 所以我可以看到什么事需要马上做完以及什么事儿需要推迟,4) 对于一些我将在未来几小时内重点关注事情, 一个特殊的优先级情况叫做 “今天”.</p>
<p>现在这也是我为什么我不再想念我的旧提纲器用 Palm 来同步整个提纲的能力. 这证明在 Palm 中,我真正想要的主要内容是顶层类别 “Tody”, 所有我必须要做的就是让 Leo 将一个标题放到一个文本文件 (并且它友好的记住了我上次使用过的文件的名称和目录) 并且我做了, 因为我已经告诉 Palm Hotsync 管理器, 说我每次同步时, 这个文件应该发送到 Palm 备忘录. Palm Hotsync 管理器在将文本文件发送给 Palm 备忘录时做得很好, 如果文件太大而无法放入一个记录从, 甚至将文件分成多个备忘录. 所以这足以让我能够在 Palm 内部浏览 (或全文搜索) 我真正想要的少量数据. 又快又脏, 但很起作用.</p>
<p>在我想要整个提纲的时候, Leo 再次赢了, 因为多亏了它跨平台的性质, 我可以在我的 Mac iBook 中使用我的整个提纲, 尽管我有时在 Windows PC (这是我的旧版本的提纲器唯一一种能运行的机器) 上编辑它. 坦率的讲, 尽管我的旧提纲器能够将整个各系塞入我的 palm/手机, 但在小屏幕和慢处理器上访问它却是很痛苦的. 现在, 当我预期我将需要整个东西时, 例如, 当我参加一个会议, 我可以将它放在我的 Mac iBook 上 (现在在 X 和 Fink 下面, 直到 Python 可以在 Aqua 下进行本机操作) 并且可以真正完全访问它.</p>
<p>我认为现在除了对编程很好外, Leo 也是一个很棒的 PIM. 能够将策略选择的部分变成一个已知的文件名, Palm 同步管理器被告知在每次同步时发送到 Palm, 这对我来讲是个诀窍. 我想, 是否你会考虑类似 &#64;flatten 指令这样的东西, 这样每次我保存提纲的时候我都能自动完成? 现在, 由我手动将我想要的节点坦化, 尽管一旦完成后, 传输到 Palm 就会自动完成.</p>
<p>你是我的英雄! 非常感谢你.</p>
</div>
<div class="section" id="dan-winkler-2">
<h3><a class="toc-backref" href="#id27">Dan Winkler 2</a><a class="headerlink" href="#dan-winkler-2" title="Permalink to this headline">¶</a></h3>
<p>另一天, 使用 Leo 的另一个重大突破-现在我意识到 Leo 是最佳的 URL 书签管理器. 我的浏览器没有更多的书签菜单或收藏夹列表. 使用 &#64;url 指令, 我只需要点击 URL 即可在我的浏览器打开它. Leo 让我以一个层级结构 (或多个层级结构) 安排 URL, 给它们附上便笺, 保存我在网站上阅读的剪报. 它比浏览器内置的任何东西都棒, 它让我可以在不同的平台和不同的机器上轻松使用不同的浏览器 (尝试使用浏览器的内置书签管理器).</p>
<p>当我在使用 Leo 作为项目管理器和个人的信息管理器时, 我可以使用有用的和相关的 URL 对每个任务和项目进行大量注释. 而且由于 URL 可以是 <a class="reference external" href="file://">file://</a> 的形式, 它们不仅适用于 web 网页或 HTML 文档; 我可以链接到任何程序所打开的任何类型磁盘上的任何文件.</p>
<p>就我能够管理的项目数量以及我能够以有用的方式发现并组织和存储的信息多少而言, Leo对我来讲是一个巨大的飞跃. 我是现在一个数据挖掘部队, 网络是我的游乐场. 每当我发现一个与其他网页有有趣联系的网页时, 这些链接就会被存储在我的 Leo 提纲, 在那里我可以找到它们并实际使用它们. 我可以每天轻松的接收数十种有价值的链接, 并将它们融入到我正在做的事情中, 让我相信它们不会丢失或忘记. 以前, 我总是因为浏览器中管理书签的困难而陷入困难. 但现在我不再是信息过载的受害者, 埋葬在互联网知识的雪崩之中; 相反, 我是掌握世界最大的推土机的专业露天矿工. 我急切地冲进堆积如山的数据, 并且将所有有价值的信息都整齐的存储和组织好. 而且, 我的知识库是一个灵活的东西, 我尽情地对数据进行重新组织和优先考虑和抚摸. 当我对它有更多的了解, 并决定以不同的方式用于不同的目的. 对我来讲, 这就是镐和蒸汽铲的区别.</p>
</div>
<div class="section" id="dan-winkler-3">
<h3><a class="toc-backref" href="#id28">Dan Winkler 3</a><a class="headerlink" href="#dan-winkler-3" title="Permalink to this headline">¶</a></h3>
<p>今年我的会计收到了一份由 LaTeX 和 Leo 生成的漂亮印刷品. 今年我的税收情况很复杂, 但是我在 Leo 中把这一切都安排和组织好了. 我有每个节点都有我的会计需要看到的数据, 将数据写到 LaTex 表格形式的一个文件中.</p>
<p>有时, 表格的一行可能会有一个通过累加数字列表而计算出来的结果. 为此, 我使用现代的是现代版的一种添加机器的纸带–我在 Leo 评论中存储了一个 lisp s-expression. 为此我喜欢 s-expressions, 因为一旦我另一行上放置了 “(+” 和在另一行上放置了闭括号 “)”, 我可以通过输入它们来填写更多的数字, 甚至可以用评论对它们进行注释. 所以在生成一个 LaTeX 文件的过程中, 我可能会这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">@</span>
<span class="p">(</span><span class="o">+</span>
<span class="mf">1165.26</span> <span class="mf">1823.70</span> <span class="p">;</span> <span class="n">May</span> <span class="mi">2002</span>
<span class="mf">123.38</span> <span class="p">;</span> <span class="n">June</span> <span class="mi">2002</span>
<span class="mf">13.50</span> <span class="p">;</span> <span class="n">July</span> <span class="mi">2002</span>
<span class="mf">13.21</span> <span class="p">;</span> <span class="n">October</span> <span class="mi">2002</span>
<span class="mf">55.25</span> <span class="p">;</span> <span class="n">November</span> <span class="mi">2002</span>
<span class="p">)</span>
<span class="nd">@c</span>
</pre></div>
</div>
<p>这是我如何得到会计人员实际看到的数字的注释记录. 我可以将他黏贴到任何 lisp 或 scheme 解释器中, 并得到总数. 添加更多的数字很容易.</p>
<p>明年, 我想我可能会更进一步. 我今年所做的事情对于加总数字来获得 LaTex 表的一行总数很有帮助. 翻事实证明我想在这些表上完成更多的处理 (这次我不得不手动这样做), 我希望行的排列顺序与数量级相反, 以便大的数字从表的开始就跳出来, 希望一个表格中所有行的总数. 所以我认为, 明年, 我不会使用一个 s-expression 来计算一行的总数, 我想我会使用 s-expressions 来生成整个表格, 从底层数据格式化为 LaTex. 所以我想明年我的 s-expressions 可能扛起了更像这样:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">@</span>
<span class="p">(</span><span class="n">table</span> <span class="s2">&quot;Widget Related Expenses&quot;</span>
    <span class="p">(</span><span class="s2">&quot;widget insurance&quot;</span> <span class="p">(</span><span class="o">+</span>
                    <span class="mf">1165.26</span> <span class="mf">1823.70</span> <span class="p">;</span> <span class="n">May</span> <span class="mi">2002</span>
                    <span class="mf">123.38</span> <span class="p">;</span> <span class="n">June</span> <span class="mi">2002</span>
                    <span class="mf">13.50</span> <span class="p">;</span> <span class="n">July</span> <span class="mi">2002</span>
                    <span class="mf">13.21</span> <span class="p">;</span> <span class="n">October</span> <span class="mi">2002</span>
                    <span class="mf">55.25</span> <span class="p">;</span> <span class="n">November</span> <span class="mi">2002</span>
                  <span class="p">))</span>
     <span class="p">(</span><span class="s2">&quot;widget shipping&quot;</span> <span class="p">(</span><span class="o">+</span>
                    <span class="mf">472.15</span> <span class="mf">651.94</span> <span class="p">;</span> <span class="n">May</span> <span class="mi">2002</span>
                    <span class="mi">54</span> <span class="p">;</span> <span class="n">June</span> <span class="mi">2002</span>
                   <span class="p">))</span>
     <span class="p">(</span><span class="s2">&quot;widget cleaning&quot;</span> <span class="p">(</span><span class="o">+</span>
                    <span class="mf">165.26</span> <span class="mf">183.70</span> <span class="p">;</span> <span class="n">May</span> <span class="mi">2002</span>
                    <span class="mf">123.38</span> <span class="p">;</span> <span class="n">June</span> <span class="mi">2002</span>
                    <span class="mf">13.50</span> <span class="p">;</span> <span class="n">July</span> <span class="mi">2002</span>
                    <span class="mf">13.21</span> <span class="p">;</span> <span class="n">October</span> <span class="mi">2002</span>
                    <span class="mf">55.25</span> <span class="p">;</span> <span class="n">November</span> <span class="mi">2002</span>
                   <span class="p">))</span>
<span class="p">)</span>
<span class="nd">@c</span>
</pre></div>
</div>
<p>该 “表” 函数的工作是返回所需的 LaTeX 代码, 以显示类别名称和值的表, 按大小排序, 并显示总数. 在 Leo 里面做一个表格, 然后用 LaTeX 使它看起来更棒, 这是一种穷人的方式. 这个想法是因为我想添加更多的数据, 我将它添加到 s-expression 中, 然后通过将其粘贴到 lisp 解释器中来重新评估整件事, 然后将结果复制回相同的 Leo 节点中, 以便 LaTeX 处理.—Dan</p>
</div>
<div class="section" id="steve-litt">
<h3><a class="toc-backref" href="#id29">Steve Litt</a><a class="headerlink" href="#steve-litt" title="Permalink to this headline">¶</a></h3>
<p>“不确定为什么你说 ‘你可以将一个计算机程序指定成一个提纲, 就像在一个提纲设置一样’ 为什么不只是说, ‘用提纲编写一个计算机程序?’有什么细微的差别吗?”—EKR</p>
<p>我可能说过上百万个像这样的理由, 但是我认为主要的理由是, 我永存的, 明亮燃烧的信念是一个程序应该在编写之前被设计. 还记得以前那些人, 他们在收到编程任务之后, 会去键盘上敲出 C 代码吗? 记得还记得他们的成品吗? 还记得他们花了多长时间才完成这个项目吗?</p>
<p>与此同时, 当我接到一个任务时, 我会花费了数小时用一堆纸, 画图表. 当我在终端前坐下时, 我已经知道我的数据结构和算法. 那个抢先开始数小时到数天 “立即开始编码” 的家伙消失了, 因为对我说, 编码只是一个秘书的任务, 而我需要做更少的重构, 甚至更糟的是, 我需要做的是做一些简单的事情. 后来, 有时我会用提纲代替纸上的图表; 在函数分解的时候, 提纲是最合适的.</p>
<p>回到你的问题: 如果我要做的是 <strong>编写</strong> 一个程序, 我只是坐在电脑前, 开始输敲打出 C 或 Python 或 Lua 或什么的. 但是那不是我的风格. 我需要 <strong>设计</strong> 一个程序, 毕竟, 一个设计只是一个程序如何编写的说明书.</p>
<p>所以在我看来, 我在 Leo 上 <strong>设计</strong> 程序, 然后, 当时间到来时, 我打开开关, 然后Leo 为我 <strong>编写</strong> 程序. 这就是我对 Leo 的看法.</p>
</div>
<div class="section" id="dave-williams">
<h3><a class="toc-backref" href="#id30">Dave Williams</a><a class="headerlink" href="#dave-williams" title="Permalink to this headline">¶</a></h3>
<p>我是一名微生物学家, 主要分析大量的细菌基因组, 我几乎全部使用 Python 工具. 几年前, 在耶鲁大学工作期间, 我让 Leo 去写 Python 和组织我的笔记.</p>
<p>现在不仅 使用 Leo 作为我在探索数据, 生成图形, 开始使用第三方应用程序进行分析等脚本的中央存储库, 而且还用于存储和组织做研究的想法, 以及从学术论文的 PDF 文件中分离的笔记.</p>
<p>我有一个日历, 解决了我所有的一般 PIM 类型信息, 以及我正在修补的任何项目的注释. 总之, 我是在工作还是在玩, Leo 通常都有涉及 :-)</p>
</div>
<div class="section" id="john-lunzer">
<h3><a class="toc-backref" href="#id31">John Lunzer</a><a class="headerlink" href="#john-lunzer" title="Permalink to this headline">¶</a></h3>
<p>一个新用户最近对我讲, “Leo 强大而灵活, 复杂而令人困惑”. 这是真的. 我相信, 使它们的软件更不复杂和不那么令人困惑经常是开发者的目标, 但是记住, Leo 已经进行了 20 多年的开发…这就使它与 Vim 和 Emacs 在成熟度方面一致. 我在 Vim 和 Emacs 方面的经验与我在 Leo 的经验相当类似. 这三个本身都是强大而灵活, 复杂而令人困惑的.</p>
<p>我相信有了这种分量和影响力的工具, 学习它们总是会有投资的. 它们都是广阔的功能森林, 充满了隐藏的珍宝, 如果它们每个人都投资于该工具, 他们的努力将得到回报. 然而, 社区的责任 (由开发者领导) 是尽可能使寻宝成为一种享受和冒险, 因为任何好的寻宝活动都应该如此.</p>
<p>而这正是 Leo 在社区的帮助下 (虽然可能很小) 不动摇的地方. 我会重申 Edward 多次说过的话, 如果你迷失, 困惑, 或不必所措, 你不要自己挣扎. 如果文档或例子无法满足你的需求. 请提问. 以我自己作为新用户 (尽管偶尔会有分歧) 的体验, 你不会被嘲笑, 蔑视或贬低, 而会得到比你最初所要求的更多的帮助. – John Lunzer &lt;<a class="reference external" href="mailto:lunzer&#37;&#52;&#48;gmail&#46;com">lunzer<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
</div>
<div class="section" id="john-lunzer-2">
<h3><a class="toc-backref" href="#id32">John Lunzer 2</a><a class="headerlink" href="#john-lunzer-2" title="Permalink to this headline">¶</a></h3>
<p>不久前, 我一直在思考编程. 我的想法集中在了人类大脑理解计算机编程的极限上. 这是通过观看 <a class="reference external" href="https://www.youtube.com/watch?v=PUv66718DII">Inventing on Principle</a> 触发的. 这是一个令人望而生畏的多层面概念, 我相信人们一生都在思考.</p>
<p>最近我一直专注于一个方面, 抽象和程序 “单元”. 我将 “单元” 定义为程序的一部分, 该程序被认为是本身可以标记并成为整体的一部分. 也许, 作为一名日常的 Leo 用户, 这容易想到, 因为 Leo 会尽其所能的迫使程序员和程序通过这个镜头来观察编程.</p>
<p>大多数工具不会同时忽视这个概念. 大多数的编程环境都有某种 “提纲” 窗口, 它允许你在更高级别上查看程序的结构. 正如我所经历的, 这个 “提纲” 视图经常由程序语言的特性所决定 (例如, 在模块, 类, 函数级上划分的提纲). 此外, 大多数的工具包含 “代码折叠” ,以帮助程序员专注于语言特定的程序单元 (同样, 例如, 在类和函数定义中也可以进行折叠).</p>
<p>Leo 将这个概念运用到了它的极限. Leo 在任意层次上提供了与语言无关的抽象. 它允许程序员在编程模式范围之外构建他们的程序. 当然, 使用语言特定的 “单元” 作为指导仍然有用, 实际上, 这是 Leo 在导入时, 根据源自 Leo 之外的程序创建初始提纲结构的过程.</p>
<p>我不能忽视任意抽象的自由, 我非常依赖它, 所以我很难使用非 Leo 环境. 总所周知, 人类的大脑工作记忆有限. 编程的行为将工作记忆延伸到了它的极限. Leo 提供了一个环境, 在其中, 程序可以无缝地重构以适应程序员个人工作记忆的边界.</p>
<p>我意识到, 这是一个 “为什么” 而不是 “怎么样”, 而且这并不能帮助任何人更好的了解 Leo. 但是,作为一名程序员, 如果你曾经对你使用的语言的组织结构感到沮丧, 在使用 Leo 之后, 你可能会惊讶的发现, 这并不是语言的问题, 而是缺乏一种的工具, 以一种对你有意义的方式来组织你的程序.</p>
</div>
<div class="section" id="adrian-calvin">
<h3><a class="toc-backref" href="#id33">Adrian Calvin</a><a class="headerlink" href="#adrian-calvin" title="Permalink to this headline">¶</a></h3>
<p>我以为我会写自己的推荐信. 我从来没有这样做过, 因为我经常会在我的推荐信上翻白眼, 但是我对 Leo 的热情是如此之高, 我必须 give “props” where props are due.</p>
<p><strong>背景</strong></p>
<p><strong>开始</strong>: 从作为一名早期的 Java 专业人员开始, 我就习惯了 Netbeans. 我像这很好. 几年之后, 我决定我想成为一名 web 开发人员.</p>
<p><strong>为什么我要找一个新的编辑器</strong>: 我想要完全可扩展的东西. 我像让它成为我自己的. 它就像你的家. 你搬进去, 它取决于你来使它成为你的 “家”. 编辑器也是这样. 你把所有的时间都花在这上面. 我认为那一定是你的. 像一双旧鞋一样舒服.</p>
<p><strong>历史</strong></p>
<p><strong>Ultra-Edit</strong>: 这是我的第一个非 ide 的IDE. 不是不尊重 UltralEdit, 我确信它有许多我从未用过的功能. 我从来没有真正有机会. 我想要一些轻便的东西, 很快就在 2006 年左右发现了 Scite.</p>
<p><strong>Notepad++</strong>: 最终我找到了 Notepad++ (我仍然认为它很棒, 并会推荐给任何人). 我已经使用了 8 年, 我仍然会偶尔使用它. 主要是因为我还是习惯了 Leo.</p>
<p><strong>现在</strong></p>
<p>我现在正处于一个年龄段, 也是我职业生涯中的一个重点, 我想使我的生活 (和工作) 尽可能简单. Leo 帮我做到了这一点. 这很难解释–提纲提供了以一种非常直观的方式将代码和思想混合的能力–甚至是将代码和生活混合. 也许这就是 “文学编程”. 我不知道. 他们从来没有在我的 CS 课程中提到这个术语. 不管是什么, 我都喜欢.</p>
<p>附带的好处–我的代码从来没有如此好的格式化和文档化!</p>
<p><strong>我个人最喜欢的事</strong></p>
<p>正如我所提到的那样, 扩展能力非常强大. 在工作中, 我在做我的老板想要做的事, 但是在家里, 我花了大部分时间去扩展 Leo. 我从未见过如此容易扩展的编辑器, 相信我, 在过去的五个月, 我已经评估了至少 20 款编辑器.</p>
<p>事情就是这样-任何我想要以用不同方式工作的事情, 或者任何我想要做得更好的事情, 我可以自己做. 我不必提交请求. 如果我至少对 google 有足够的好奇心或者寻求一点帮助的话, 我可以做到我想要的.</p>
<p>凡你能说得出的.</p>
<ul class="simple">
<li>如果我希望日志以不同的方式工作, 或创建我自己的输出窗格:没为题.</li>
<li>如果我像将 PHP 单元测试添加到菜单中, 没问题.</li>
<li>如果我想要成为个人组织者, 混入到我的工作流中, 没问题.</li>
<li>如果我想要将我的 python, PHP 代码, 日志等全部集成在一起, 以便任何事从 20000 英尺的高度来看都合情合理, 没有问题.</li>
<li>如果我想要改变整个外观和感觉…我指的是一切…不仅仅是一些东西, 没有问题.</li>
<li>如果我想能够轻松的向非技术同时解释代码, 没有问题. 任何具有某种程度智力的人都可以跟随这个提纲.</li>
</ul>
<p>你明白了…</p>
<p>对我来说, 这意味着一切.</p>
</div>
</div>
<div class="section" id="id10">
<h2><a class="toc-backref" href="#id34">为什么 Leo 值得注意</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>Leo 是理解, 研究和组织任何复杂数据(包括计算机编程)的绝佳工具. 在 Leo 历史上第一个伟大的 Aha 是, web 是伪装的提纲. Leo 的输入模块 (&#64;auto) 使研究其他人的程序变得容易. Leo 一贯的提纲结构阐明了整个程序结构, 并使许多类型的评论变得多余.</p>
<p>Leo 也是一款极好的代码和数据浏览器. 与其他许多折叠编辑器不同, Leo记得当你上次保存一个提纲时, 哪些节点被拓展了. 这非常重要. 而且 Leo 的克隆让你随心所欲的组织任何数据, 即使所有的折叠都崩溃了.</p>
<p>Leo 是独特而强大的脚本环境. 这种力量来自三个来源: Leo 的 API, Leo 从提纲组合脚本的能力和 Leo 的基础数据结构, 一个有向无环图, 这是Leo克隆的基础.</p>
<p>Leo 的 API 的构成主要是生成器 (例如 c.all_positions()、p.self_and_subtree()等) 和属性 (例如 p.b、p.h、p.ghx 和 p.v.u). Leo 的 API 使编写脚本来访问或改变任何节点变得微不足道. 就我所知, 这些功能是独一无二的. 在 vim 或 Emacs 中模拟它们是可能的, 但在 C 中模拟 Python 的功能也是可能的.</p>
<p>就我所知, 没有其他的脚本环境允许你从提纲中来组合脚本.  &#64;file , &#64;clean , &#64;auto , &#64;others 和章节引用和定义使其成为可能. 章节参考和定义以 noweb 语言为模型, 但是所有的 Leo 脚本组成功能都完全集成到 Leo 的提纲结构中.</p>
<p>Leo 的提纲节点有标题 (p.h) 和正文 (p.b) 和可扩展信息(p.v.u). 标题是在 p.b 和 p.v.u 中数据的描述 (元数据). 脚本可以使用元数据快速地发现和分类数据. Leo 关于标题的 &#64; 约定 (&#64;clean, &#64;file, &#64;auto, &#64;html, 等.) 显示了此节点类型的可扩展性.</p>
<p>这个理论非常重要. 以下在实践中也很重要:</p>
<ul class="simple">
<li>Python 中的本地脚本, 可以完全访问所有 Leo 的源代码.</li>
<li>Leo 的插件架构.</li>
<li>Leo 的 rst3 命令, vim, xemacs 和 ILeo (IPython bridge), 和 leoBridge 模块.</li>
<li>Leo 的小型缓冲命令, 从 Emacs 厚着脸皮地借用.</li>
<li>&#64;test 和 &#64;suite: Leo 的面向提纲的单元测试框架.</li>
<li>&#64;button: 将脚本带入数据.</li>
<li>Leo 的面向提纲的指令.</li>
</ul>
<p>某种意义上讲, &#64;clean 的发明/研究要早于完成 Leo 的年份.</p>
<p>致谢: 与 Leo 社区的开发者和用户合作 20 多年是非常荣幸的. 我唯一后悔的是 Bernhard Mulder 和 Bob Fitzwater 不再和我们在一起. 两者都做出了重要的贡献. Bob Fitzwater 是我的导师. 他温和地催促我考虑设计, 而不仅仅是 “有点别扭”. Bernhard Mulder 贡献了 Leo 最重要的两个元素: Leo的遍历器 (生成器) 和原始的 &#64;shadow 算法. 如果没有他, &#64;clean 和 修改后的 Mulder/Ream 算法都不可能发成. 我思念这两位伟大的思想家. 他们都为他们所创造的东西感到自豪.</p>
<p>一个成功的软件工具就是能用来做一些连它们的作者做梦都想不到的事情.’ – Stephen Johnson</p>
<p>Leo的在这个得分上取得了很大的成功. 20 年前, 我没有预见到这些发展: Leo 的 minibuffer, &#64;button, &#64;test, &#64;auto, &#64;clean, Leo 的插件架构, rst3 命令, Leo bridge 和 IPython bridge. 当然还可以添加许多其他的功能和用法. 没有 Leo 社区的天才们, 这些都不会发生. 这些功能创造了 Leonine 的世界. 谁知道结果会是什么样…</p>
<p>Edward K. Ream</p>
<div class="section" id="offray-luna-cardenas">
<h3><a class="toc-backref" href="#id35">Offray Luna Cárdenas</a><a class="headerlink" href="#offray-luna-cardenas" title="Permalink to this headline">¶</a></h3>
<p>这种总是呈现提纲的想法一直是我组织写作的关键, 有些同事过去发现, 当我么纠正他们的文本时, 这有助于他们.</p>
<p>&gt; Leo 的克隆让你随心所欲的组织任何数据, 即便所有的目录都折叠了.</p>
<p>对我而言, 这是 Leo 最强大但被误解的功能. 大多数将它与其他的 IDE 对比的人都叫嚷着说为什么 Leo 不能更加自动地施加结构, 但是在 Leo 中由你做主. 你来施加基础结构…</p>
<p>对我而言, Leo 第二个主要的见解是 (在几乎任何的ermergent旁经常显示三种结构) 是让树具有可编程的结构, 能够通过树内部的任何节点来理解和修改. 我认为 Leo 将结构和自我指涉引入到 dumb flat file word 中. 所以你可以从一个 (或多个) 文件创建一个树, 按照你想要的方式解构和重构它, 在行动上自动化这种方式, 并与外部世界对话…我越关注交互式写作和远离 unix 启发的 OS 世界, 则第二个见解对我来说就变得越重要. 我不需要对 flat file 进行结构/重构或施加结构, 而是通过 (交互式) 书写来使用提纲构建想法, 而且我需要将提纲作为完全可编程的对象. 这是我的大部分 Leo 体验中最本质的…</p>
<p>感谢 Leo 及其带来的所有关键灵感. 和往常一样, 感谢 Leo 社区的精神食粮.</p>
</div>
<div class="section" id="speed-s-comments">
<h3><a class="toc-backref" href="#id36">Speed’s comments</a><a class="headerlink" href="#speed-s-comments" title="Permalink to this headline">¶</a></h3>
<p>我唯一的投入就是让 Leo 对来讲我如此特殊.</p>
<p>在仅仅学习了 Leo 的几件事之后, 并且在用 &#64;others 替换了章节引用之后, 编写代码成了一场游戏而不是一件苦差事.</p>
<p>一旦一个想法变得复杂, 我就添加一个新的 &#64;ohters, 并将难题分解成组块, 直到所有的难题都变得简单.</p>
<p>我通常在提纲底部克隆该章节, 然后在父级别添加足够的逻辑, 以便可以用控件 B 来测试难题.</p>
<p>这是我对单元测试的逆向实现.这种类型的 ‘单元测试’ 永远不需要在代码被改进 (总是) 时重构.</p>
<p>克隆的 “测试件” 可以降级到一个测试章节, 然后新的组块随后被克隆到任何对该项目有实际意义的结构中.</p>
<p>在实践中, 这对我来说很有乐趣.</p>
<p>没有 Leo 的编码不再更加有趣. 我最近使用 Microsoft’s Visual Studio 完成了一个 c++ socket 服务器, 与没有 Leo 的人合作.Microsoft 的工具非常棒, 该项目顺利完成, 但是乐趣简直没有了.</p>
<p>无论如何, 非常感谢 Leo 的伟大视角.</p>
</div>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id37">我是如何发现 Leo 的</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<div class="section" id="satish-goda">
<h3><a class="toc-backref" href="#id38">Satish Goda</a><a class="headerlink" href="#satish-goda" title="Permalink to this headline">¶</a></h3>
<p>我发现 Leo 已经快有 14个月了, 今天我回忆起我是如何找到它的.</p>
<p>我正在 Github 上搜索词语 “QWidgetAction”, 并且在 Leo 的代码库中找到了它的使用用法. 然而, 好奇害死猫, 我对 Leo 很好奇, 阅读并下载了它.</p>
</div>
<div class="section" id="rob-keeney">
<h3><a class="toc-backref" href="#id39">Rob Keeney</a><a class="headerlink" href="#rob-keeney" title="Permalink to this headline">¶</a></h3>
<p>我在寻找 ECCO (有人记得这个程序吗?) 的替代品时发现了 Leo. 我使用了 ECCO 15年, 之后它不再支持了, 并且铁杆用户的核心团队最终丧失了对该程序所有者会开源代码的希望.</p>
<p>不管如何, 我不记得是多久以前; 我记得, 至少是10年前. 在大多数方面, Leo 是对 ECCO 的重大改进, 我并不后悔这次转变. 然而, 有一件事我仍然很想念 ECCO , 并希望有一个很好的 Leo 集成, 就是日历. ECCO 可以打印几乎任何类型的日历, 尤其是任何尺寸上的任何格式. 我真的想念这个. 我知道市场上没有其他的 PIM 有这种的灵活性.</p>
<p>也许其他的 Leo 用户想出了如何将日历与 Leo结合起来; 我没有, 也很想知道(如果可能的话).</p>
</div>
<div class="section" id="chris-george">
<h3><a class="toc-backref" href="#id40">Chris George</a><a class="headerlink" href="#chris-george" title="Permalink to this headline">¶</a></h3>
<p>当我在寻找一款支持克隆, 在 Linx 上运行, 并且不是网站的提纲时, 我找到了 Leo. 我居住在一个世间边缘的小农场, 我们的互联网一直都很糟糕.</p>
<p>我在 2007 年 拿起 Leo. 如果在此期间我学到了一件事, 那就是对于 Leo, 一切皆有可能.</p>
</div>
<div class="section" id="terry-brown">
<h3><a class="toc-backref" href="#id41">Terry Brown</a><a class="headerlink" href="#terry-brown" title="Permalink to this headline">¶</a></h3>
<p>我想我在使用 Leo 之前, 一直在使用 Freemind, 尽管我已经花了很长时间使用基于提纲 hnb 的控制台, 它显然已恢复为 tines  <a class="reference external" href="https://github.com/larrykollar/tines">https://github.com/larrykollar/tines</a></p>
</div>
<div class="section" id="kent-tenney">
<h3><a class="toc-backref" href="#id42">Kent Tenney</a><a class="headerlink" href="#kent-tenney" title="Permalink to this headline">¶</a></h3>
<p>我认为我发现 Leo 是对文学编程短暂兴趣的结果. 不记得日期, 但是在 Leo 从 C++ 移植到 Python 之前.</p>
<p>当我从高中时代的一个好心人那得知, Edward 居住小镇对面的 kitty 街角时, I was SOLD!</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="leo_toc.html">
              <img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="preface.html"
                        title="previous chapter">Leo 简介</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="acknowledgements.html"
                        title="next chapter">致谢</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="acknowledgements.html" title="致谢"
             >next</a> |</li>
        <li class="right" >
          <a href="preface.html" title="Leo 简介"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="leo_toc.html">Leo 5.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="preliminaries.html" >前言</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1997-2017, Edward K. Ream.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>